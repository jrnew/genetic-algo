\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{color, hyperref, amsmath, graphicx, Rd}

\setlength{\oddsidemargin}{0in} \setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in} \setlength{\textheight}{8.5in}
\setlength{\textwidth}{6.5in} \setlength{\textheight}{8.5in}

\title{STAT 243: \\
	Model Selection with\\ 
	Genetic Algorithms using \texttt{GA}}
\author{Eddie Buehler, Yang Hu \& Jin Rou New\\
	University of California, Berkeley}

\date{Version 1.0, \today}

\setlength\parindent{0pt}
\setlength{\parskip}{\baselineskip}% to get space between paragraphs


\begin{document}
\maketitle

\section{Introduction}
\label{sec:introduction}
A genetic algorithm is an optimization technique that mimics the
biological process of natural selection. The basic strategy is to take
a population of candidate solutions and ``evolve" them over many generations towards an
optimal solution. Continuing the biology analogy, the
population is typically represented as a collection of a series of bits called chromosomes. A fitness function is evaluated at each iteration to
determine how well the current population of chromosomes solves the objective
function. A genetic algorithm has the following steps: 
\begin{enumerate}
	\item Calculate fitness of chromosomes. Often, the
          fitness is the value of the objective function solving the
          optimization. The better the fitness, the better solution
          the chromosomes will provide.
	\item Select chromosomes to form a mating pool based on their
          fitness. This process is performed stochastically, with more
          fit chromosomes having a higher probability of being
          selected. 
	\item Recombine parent chromosomes from the mating pool. This
          is the first step in producing the next generation of
          chromosomes. The parents' genes are combined through either a
          one- or two-point crossover. In a one-point crossover, a
          single point on each parent's chromosome is selected. Any genes
          after this point are swapped between parents. Two-point
          crossover works similarly except that there are two
          crossover points for gene swapping.
	\item Apply mutation to produce the resulting generation of
          chromosomes. After crossover, each gene in the resulting
          population has a finite probability to flip its value. Typically a
          small fraction of genes (around 0.01) is selected to
          mutate.
        \item Repeat until either a set number of generations or a
          criterion on the objective function is reached.
\end{enumerate}

\section{Code}
\label{sec:code}
We took the S3 approach to object-oriented programming for our package and created functions that were as modular as possible to facilitate code creation, maintenance and testing.

For a given data set, e.g. the built-in \texttt{airquality} data set in \texttt{R}, the user can carry out model selection for an ordinary linear regression of the variable \texttt{Ozone} on other variables in the data set with the main function in the package as follows:
\begin{verbatim}
ga <- select_model(data = airquality, yvar = "Ozone")
\end{verbatim}

Finer control of other parameters in the genetic algorithm for model selection is possible by changing the other function arguments. More details can be found in the \texttt{GA} manual in the ~\nameref{sec:appendix}.

The output of the results can be viewed using the following commands:
\begin{verbatim}
summary(ga)
model(ga)
\end{verbatim}

The result of this function is an object of \texttt{GA} class that contains the settings, model data, final population of chromosomes/models, model evaluation values of this population and all results of model selection using the genetic algorithm.

In the genetic algorithmic approach to model selection, a population of models, i.e. chromosomes with number of genes equal to the number of model variables under consideration, and with each gene taking a value of 1 if the model variable is included and 0 otherwise, is first initialized. This population then undergoes many iterations of reproduction. In the reproduction stage, each model/chromosome is then evaluated based on the desired model selection criterion, e.g. Akaike's Information Criterion. Chromosomes are then selected into the mating pool based on how well they perform on the model selection criterion. 

Next, 2 parent chromosomes are randomly selected from the mating pool to form a child chromosome, with some probability of recombination/crossover occurring in the process. This is repeated until the desired number of child chromosomes for the next generation is reached. Finally, mutation is applied with a low probability to each gene in the population of child chromosomes. The resulting population of child chromosomes forms the next generation. The whole process is repeated for a desired number of iterations. The model/chromosome with the minimum value of the model evaluation criterion across all generations is then the best model.

The following subsections elaborate on the main subfunctions in the \texttt{GA} package; for more detailed documentation, please refer to the \texttt{GA} manual in the ~\nameref{sec:appendix}.

\subsection*{initialize function}
We sample uniformly from the set of \{0, 1\} with replacement as many genes as is required, i.e. the product of the number of variables under consideration and the population size desired, for the initial population of chromosomes.

\subsection*{evaluate function}
We compute the value of the model evaluation criterion for every model/chromosome in the population. The default model evaluation criterion is Akaike Information Criterion (AIC). The user can also choose to use Bayesian Information Criterion (BIC) or define his/her own function.

\subsection*{select function}
The default selection method is ``rank'', which refers to Linear Rank Selection (LRS). In LRS, chromosomes are first given ranks $r_i$ for $i = 1, ..., n$, where $n$ is the number of chromosomes in the population. The chromosome with the best (minimum) model evaluation criterion is assigned a rank of $n$. Chromosomes are then selected into the mating pool randomly with probability proportional to their relative rank, until the desired size of the mating pool is reached. This is done with the following algorithm:
\begin{enumerate}
\item Calculate for each chromosome its probability to be selected, $p_i = \frac{r_i}{\sum\limits_{i=1}^n{r_i}}$. Since the best chromosome is given the largest rank, it also has a highest probability of being selected.
\item Calculate the cumulative probability for each chromosome to be selected, $pc_i = \sum\limits_{j=1}^i{p_j}$.
\item Generate a random number $u$ uniformly in the range [0, 1].
\item Select the chromosome with index $i$ if $pc_i < u < pc_{i+1}$
\item Repeat until the desired number of chromosomes in the mating pool is select.
\end{enumerate}

The alternative selection method is ``tournament'', which refers to Tournament Selection. The idea is simple; in Tournament Selection, we randomly select 2 chromosomes from the population. The chromosome with the better model evaluation criterion is selected into the mating pool. This process is repeated (with replacement of both chromosomes each time) until the desired number of chromosomes in the mating pool is reached.

\subsection*{recombine function}
Recombination occurs with probability \texttt{prob\_recombine} for every set of 2 parent chromosomes; the child chromosome is simply a copy of the first parent chromosome if no recombination occurs. We implemented three methods of recombination: crossover at one point (``onepoint''), crossover at two points (``twopoint'') and uniform crossover (``uniform'').

For one-point crossover, a break point index $b$ is uniformly sampled from the set of \{1, ..., g\}, where $g$ is the number of genes on each chromosome. The resulting child chromosome then takes genes 1 to $b$ from the first parent and genes $b+1$ to $g$ from the second parent.

For two-point crossover, two break point indices $b_1$ and $b_2$ are uniformly sampled without replacement from the set of \{1, ..., g\}. The resulting child chromosome then takes genes 1 to $b_1$ from the first parent, genes $b_1+1$ to $b_2$ from the second parent, and finally genes $b_2+1$ to $g$ from the first parent.

For uniform crossover, the child chromosome has equal probability of receiving each gene from either parent.

\subsection*{mutate function}
We generate as many Bernoulli variables as there are genes in the population of chromosomes. For each gene, we set:

\[
\text{new\_gene} \sim
\begin{cases}
Bernoulli(\texttt{prob\_mutate}), & \text{if current\_gene = 0}\\
Bernoulli(1-\texttt{prob\_mutate}), & \text{if current\_gene = 1}
\end{cases}
\]

This is equivalent to mutating each gene (i.e. changing a value of 1 to 0 and vice versa) with a probability of \texttt{prob\_mutate}, but doing it in this manner allows for vectorized operations.

\section{Testing} 
\label{sec:testing}

Automated testing of auxilliary functions was performed using R's
\texttt{testthat} package. This approach has several advantages over
manual testing. It provides functions that allow the user to clearly
define expected inputs, outputs, and errors while
testing. Additionally, re-testing simply involves running the test file
again, and multiple test files can be run at once. Finally, it displays test progress visually, showing whether
each tests passes, fails, or produces an error.

Each function was tested for correct inputs and outputs. The number of
inputs, their class, and their dimensions was specified using the
\texttt{expect\_that(x, equals(y))} and \texttt{expect\_that(x,
  is\_a(y))} functions. Similarly, the number of outputs, their class,
and their dimensions were specified using the same
functions. Further constraints on certain inputs and outputs were tested as
well. Since chromosomes are composed of bits, the elements in the
population matrix must be either zero or one. This specification was
tested by ensuring that the minimum of the population is 0 and the
maximum is 1.

Although most functions had stochastically determined outputs and thus
their exact values could not be predicted, the \texttt{mutate}
function had two testable outcomes. First, if the mutation rate was
set to zero, no genes were expected to mutate, so the output
population should be the exact same as the input population. Secondly,
if the mutation rate were one, all of the genes in the population
should switch their value. Both of these scenarios were tested to
ensure proper behavior in the \texttt{mutate} function.

A testing function was written for each function in the \texttt{ga}
package. These files can be found in the ~/testing folder of the
Github repository. All testing files can be run at once using the
\texttt{test\_dir(``~/testing'')} command in R.

\section{Contributions} 
\label{sec:contributions}
\subsection{Code writing}
General structure: JRN\\
Functions: JRN, YH

\subsection{Code testing}
Function testing: EB\\
Overall function tests: YH

\subsection{Documentation}
Manual creation: EB\\
Project write-up: Introduction (EB), Code (JRN), Testing (EB, YH)

\section{Appendix}
\label{sec:appendix}
\input{overviewallfunctions.tex}

\end{document}